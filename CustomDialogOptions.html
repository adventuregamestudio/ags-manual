<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Custom dialog options rendering</title>
  <link rel="stylesheet" href="css/normalize.css" />
  <link rel="stylesheet" href="css/main.css" />
  <link href="static/favicon.ico" rel="icon" type="image/x-icon" />
</head>
<body>


  <div class="container">
    <header>
      <label class="toggle-control" for="dark_mode_toggle">
        <input type="checkbox" checked="checked"  id="dark_mode_toggle">
        <span class="control"></span>
      </label>
      <script src="js/darkmode.js"></script>
      <script src="js/mark.min.js"></script>
      <label class="search_input" for="search_input">Search:</label>
      <input type="search" id="search_input">
      <ul id="search_results"></ul>
    </header>

  <nav>
    <a href="index.html">
      <svg id="cup" width="72" height="48" viewBox="0 0 12 8" preserveAspectRatio="xMidYMid meet">
        <g shape-rendering="crispEdges">
          <rect width="10" height="7" fill="#ffffff" />
          <svg y="1">
            <rect width="12" height="5" fill="#ffffff" />
          </svg>
          <svg x="1">
            <rect width="8" height="8" fill="#ffffff" />
          </svg>
          <svg x="1" y="1">
            <rect width="8" height="5" fill="#2a7fff" />
          </svg>
          <svg x="2" y="6">
            <rect width="6" height="1" fill="#2a7fff" />
          </svg>
          <svg x="9" y="2">
            <rect width="2" height="3" fill="#2a7fff" />
          </svg>
          <svg x="9" y="3">
            <rect width="1" height="1" fill="#ffffff" />
          </svg>
          <svg x="2" y="2">
            <rect width="6" height="3" fill="#0000d4" />
          </svg>
          <svg x="3" y="5">
            <rect width="4" height="1" fill="#0000d4" />
          </svg>
          <svg x="2" y="1">
            <rect width="6" height="1" fill="#ffffff" />
          </svg>
        </g>
      </svg>
    </a>
    <h1>
      <a href="index.html">AGS Manual</a>
    </h1>
    <ul>
      <li><a href="genindex.html">Index</a></li>
    </ul>
<ul>
<li><a href="#custom-dialog-options-rendering"><span>Custom dialog options rendering</span></a></li>
</ul>
  </nav>

  <main>
<section id="custom-dialog-options-rendering" class="level2">
<h2><a href="#custom-dialog-options-rendering">Custom dialog options rendering</a></h2>
<p>By default, AGS comes with two types of dialog options -- displaying them using the size and position of an existing GUI, or creating a text window to display the options in.</p>
<p>As of AGS 3.1, if neither of these methods suit you (for example, because you want to use picture-based dialog options, or you want to add scroll arrows), you can now implement the dialog options display yourself in the script.</p>
<p><strong>NOTE:</strong> This topic involves some advanced scripting. If you're just starting out with AGS, please just use one of the built-in dialog option styles for now, and come back to this later when you're comfortable with scripting.</p>
<p>To write your custom dialog options code, you need to do the following:</p>
<ul>
<li>Add a <code>dialog_options_get_dimensions</code> function to your script (an example follows). This function is called by AGS to find out which part of the screen you will be drawing onto. By setting the width and height to values greater than 0, the custom dialog system is activated.</li>
<li>Add a <code>dialog_options_render</code> function, which is called by AGS when it needs to draw the dialog options. A standard script <a href="DrawingSurface.html"><code>DrawingSurface</code></a> is supplied, which you can use to draw onto.</li>
<li>Optionally, add a <code>dialog_options_mouse_click</code> function. This is called by AGS if the player clicks the mouse anywhere on dialog options GUI. You might want to use this to process clicks on dialog options, and also on some custom scroll arrows, for example.</li>
<li>Optionally, add a <code>dialog_options_key_press</code> function. This is called by AGS if the player presses any key while custom dialog options are shown on screen. You can use this to implement key-controlled selection of dialog option, for example.</li>
<li>Optionally, add a <code>dialog_options_repexec</code> function. This works similarly to general <code>repeatedly_execute</code> function, but is called only if custom dialog options are shown on screen. You may use this to handle any other situations, such as determining which option the mouse is currently hovering over, or scripting time-related actions.</li>
</ul>
<p>These functions don't have to go in the global script; you can put them in any script you like. However, beware that if the functions are present in more than one script they could interfere with each other and cause problems.</p>
<p><strong>COMPATIBILITY NOTE:</strong> The older versions of AGS (pre-3.4.0) were working with somewhat different set of functions. There was no <code>dialog_options_repexec</code> and <code>dialog_options_key_press</code>, but you had to add <code>dialog_options_get_active</code> function instead in which you'd set an active dialog option (or none) on each game update, for example, depending on the cursor position. Mouse clicks were processed by the engine, and if an active option was set in <code>dialog_options_get_active</code> then it was run automatically. There is a compatibility switch in the General Settings called "Use old-style dialog options rendering API" that toggles between the old and new behavior. If you have imported older project and want to keep old dialog option scripts, then make sure it's enabled. If you wish to update your game to the new behavior, then turn it off.</p>
<p><strong>IMPORTANT:</strong> When adding the functions to the script, they all take in a parameter of type <a href="DialogOptionsRenderingInfo.html"><code>DialogOptionsRenderingInfo</code></a>. The dialog_options_mouse_click function has an extra parameter for the mouse button, and dialog_options_key_press has an extra parameter for the key code. See the example below.</p>
<p><strong>IMPORTANT:</strong> All of the Custom Dialog functions run on the non-blocking thread. That means that you should not make any blocking calls, such as Character.Say, Wait or Display within them, as they may not behave correctly.</p>
<p><strong>Example A. Classic mouse controls</strong></p>
<pre><code>int dlg_opt_color = 14;
int dlg_opt_acolor = 13;
int dlg_opt_ncolor = 4;

function dialog_options_get_dimensions(DialogOptionsRenderingInfo *info)
{
  // Create a 200x200 dialog options area at (50,100)
  info.X = 50;
  info.Y = 100;
  info.Width = 200;
  info.Height = 200;
  // Enable alpha channel for the drawing surface
  info.HasAlphaChannel = true;
  // Put the text parser at the bottom (if enabled)
  info.ParserTextBoxX = 10;
  info.ParserTextBoxY = 160;
  info.ParserTextBoxWidth = 180;
}

function dialog_options_render(DialogOptionsRenderingInfo *info)
{
  info.Surface.Clear(dlg_opt_color);
  int ypos = 0;
  // Render all the options that are enabled
  for (int i = 1; i &lt;= info.DialogToRender.OptionCount; i++)
  {
    if (info.DialogToRender.GetOptionState(i) == eOptionOn)
    {
      if (info.ActiveOptionID == i)
        info.Surface.DrawingColor = dlg_opt_acolor;
      else
        info.Surface.DrawingColor = dlg_opt_ncolor;

      info.Surface.DrawStringWrapped(5, ypos, info.Width - 10,
              eFontFont0, eAlignLeft, info.DialogToRender.GetOptionText(i));
      ypos += GetTextHeight(info.DialogToRender.GetOptionText(i), eFontFont0, info.Width - 10);
    }
  }
}

function dialog_options_repexec(DialogOptionsRenderingInfo *info)
{
  info.ActiveOptionID = 0;
  if (mouse.y &lt; info.Y || mouse.y &gt;= info.Y + info.Height ||
      mouse.x &lt; info.X || mouse.x &gt;= info.X + info.Width)
  {
    return; // return if the mouse is outside UI bounds
  }

  int ypos = 0;
  // Find the option that corresponds to where the mouse cursor is
  for (int i = 1; i &lt;= info.DialogToRender.OptionCount; i++)
  {
    if (info.DialogToRender.GetOptionState(i) == eOptionOn)
    {
      ypos += GetTextHeight(info.DialogToRender.GetOptionText(i), eFontFont0, info.Width - 10);
      if ((mouse.y - info.Y) &lt; ypos)
      {
        info.ActiveOptionID = i;
        return;
      }
    }
  }
}

function dialog_options_mouse_click(DialogOptionsRenderingInfo *info, MouseButton button)
{
  if (info.ActiveOptionID &gt; 0)
    info.RunActiveOption();
}
</code></pre>
<p>The examples above are slightly naive; in reality you would probably want to track the Y position of each option in a variable to save having to continually scan through all the options.</p>
<p><strong>Example B. Keyboard controls</strong></p>
<pre><code>int dlg_opt_color = 14;
int dlg_opt_acolor = 13;
int dlg_opt_ncolor = 4;

function dialog_options_get_dimensions(DialogOptionsRenderingInfo *info)
{
  // Create a 200x200 dialog options area at (50,100)
  info.X = 50;
  info.Y = 100;
  info.Width = 200;
  info.Height = 200;
  info.ActiveOptionID = 1; // set to first option
}

function dialog_options_render(DialogOptionsRenderingInfo *info)
{
  info.Surface.Clear(dlg_opt_color);
  int ypos = 0;
  // Render all the options that are enabled
  for (int i = 1; i &lt;= info.DialogToRender.OptionCount; i++)
  {
    if (info.DialogToRender.GetOptionState(i) == eOptionOn)
    {
      if (info.ActiveOptionID == i)
        info.Surface.DrawingColor = dlg_opt_acolor;
      else
        info.Surface.DrawingColor = dlg_opt_ncolor;

      info.Surface.DrawStringWrapped(5, ypos, info.Width - 10,
          eFontFont0, eAlignLeft, info.DialogToRender.GetOptionText(i));
      ypos += GetTextHeight(info.DialogToRender.GetOptionText(i), eFontFont0, info.Width - 10);
    }
  }
}

function dialog_options_key_press(DialogOptionsRenderingInfo *info, eKeyCode keycode)
{
  if (keycode == eKeyUpArrow)
  {
    // check all options upwards until found an active one
    for (int next_opt = info.ActiveOptionID - 1; next_opt &gt;= 1; next_opt--)
    {
      if (info.DialogToRender.GetOptionState(next_opt) == eOptionOn)
      {
        info.ActiveOptionID = next_opt;
        break;
      }
    }
  }
  else if (keycode == eKeyDownArrow)
  {
    // check all options downwards until found an active one
    for (int next_opt = info.ActiveOptionID + 1; next_opt &lt;= info.DialogToRender.OptionCount; next_opt++)
    {
      if (info.DialogToRender.GetOptionState(next_opt) == eOptionOn)
      {
        info.ActiveOptionID = next_opt;
        break;
      }
    }
  }
  else if (keycode == eKeyReturn || keycode == eKeySpace)
  {
    info.RunActiveOption();
  }
}
</code></pre>
<p>For more detail on the commands used here, see the <a href="DialogOptionsRenderingInfo.html"><code>DialogOptionsRenderingInfo</code></a> page.</p>
<p><em>Compatibility:</em> Supported by <strong>AGS 3.1.0</strong> and later versions.<br> dialog_options_repexec and dialog_options_key_press callbacks are supported since <strong>AGS 3.4.0</strong>.</p>
</section>
  </main>


  <footer>
    <p>
      <a href="/jslicensing.html" data-jslicense="1">Third-party JavaScript licensing</a><br>
      Build: bcdce9f96320023ed88020a5a809b2f4cc62bfba
    </p>
  </footer>

  <script src="js/search.js"></script>
  </div>
</body>
</html>
