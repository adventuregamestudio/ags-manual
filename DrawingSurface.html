<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>DrawingSurface functions and properties</title>
  <link rel="stylesheet" href="css/normalize.css" />
  <link rel="stylesheet" href="css/main.css" />
  <link href="static/favicon.ico" rel="icon" type="image/x-icon" />
</head>
<body>


  <div class="container">
    <header>
      <label class="toggle-control" for="dark_mode_toggle">
        <input type="checkbox" checked="checked"  id="dark_mode_toggle">
        <span class="control"></span>
      </label>
      <script src="js/darkmode.js"></script>
      <script src="js/mark.min.js"></script>
      <label class="header_input" for="search_input">Search:</label>
      <input type="search" id="search_input">
      <label for="citoggle" class="header_input">Aa</label>
      <input type="checkbox" id="citoggle" onclick="citoggle_clicked()">
      <ul id="search_results"></ul>
    </header>

  <nav>
    <a href="index.html">
      <svg id="cup" width="72" height="48" viewBox="0 0 12 8" preserveAspectRatio="xMidYMid meet">
        <g shape-rendering="crispEdges">
          <rect width="10" height="7" fill="#ffffff" />
          <svg y="1">
            <rect width="12" height="5" fill="#ffffff" />
          </svg>
          <svg x="1">
            <rect width="8" height="8" fill="#ffffff" />
          </svg>
          <svg x="1" y="1">
            <rect width="8" height="5" fill="#2a7fff" />
          </svg>
          <svg x="2" y="6">
            <rect width="6" height="1" fill="#2a7fff" />
          </svg>
          <svg x="9" y="2">
            <rect width="2" height="3" fill="#2a7fff" />
          </svg>
          <svg x="9" y="3">
            <rect width="1" height="1" fill="#ffffff" />
          </svg>
          <svg x="2" y="2">
            <rect width="6" height="3" fill="#0000d4" />
          </svg>
          <svg x="3" y="5">
            <rect width="4" height="1" fill="#0000d4" />
          </svg>
          <svg x="2" y="1">
            <rect width="6" height="1" fill="#ffffff" />
          </svg>
        </g>
      </svg>
    </a>
    <h1>
      <a href="index.html">AGS Manual</a>
    </h1>
    <ul>
      <li><a href="genindex.html">Index</a></li>
    </ul>
<ul>
<li><a href="#drawingsurface-functions-and-properties"><span><code>DrawingSurface</code> functions and properties</span></a>
<ul>
<li><a href="#drawingsurfaceclear"><span><code>DrawingSurface.Clear</code></span></a></li>
<li><a href="#drawingsurfacecreatecopy"><span><code>DrawingSurface.CreateCopy</code></span></a></li>
<li><a href="#drawingsurfacedrawcircle"><span><code>DrawingSurface.DrawCircle</code></span></a></li>
<li><a href="#drawingsurfacedrawimage"><span><code>DrawingSurface.DrawImage</code></span></a></li>
<li><a href="#drawingsurfacedrawline"><span><code>DrawingSurface.DrawLine</code></span></a></li>
<li><a href="#drawingsurfacedrawmessagewrapped"><span><code>DrawingSurface.DrawMessageWrapped</code></span></a></li>
<li><a href="#drawingsurfacedrawpixel"><span><code>DrawingSurface.DrawPixel</code></span></a></li>
<li><a href="#drawingsurfacedrawrectangle"><span><code>DrawingSurface.DrawRectangle</code></span></a></li>
<li><a href="#drawingsurfacedrawstring"><span><code>DrawingSurface.DrawString</code></span></a></li>
<li><a href="#drawingsurfacedrawstringwrapped"><span><code>DrawingSurface.DrawStringWrapped</code></span></a></li>
<li><a href="#drawingsurfacedrawsurface"><span><code>DrawingSurface.DrawSurface</code></span></a></li>
<li><a href="#drawingsurfacedrawtriangle"><span><code>DrawingSurface.DrawTriangle</code></span></a></li>
<li><a href="#drawingsurfacerelease"><span><code>DrawingSurface.Release</code></span></a></li>
<li><a href="#drawingsurfacedrawingcolor"><span><code>DrawingSurface.DrawingColor</code></span></a></li>
<li><a href="#drawingsurfacegetpixel"><span><code>DrawingSurface.GetPixel</code></span></a></li>
<li><a href="#drawingsurfaceheight"><span><code>DrawingSurface.Height</code></span></a></li>
<li><a href="#drawingsurfaceusehighrescoordinates"><span><code>DrawingSurface.UseHighResCoordinates</code></span></a></li>
<li><a href="#drawingsurfacewidth"><span><code>DrawingSurface.Width</code></span></a></li>
</ul></li>
</ul>
  </nav>

  <main>
<section id="drawingsurface-functions-and-properties" class="level2">
<h2><a href="#drawingsurface-functions-and-properties"><code>DrawingSurface</code> functions and properties</a></h2>
<p>The DrawingSurface family of functions allow you to directly draw onto dynamic sprites and room backgrounds in the game. You get a drawing surface by calling <a href="DynamicSprite.html#dynamicspritegetdrawingsurface"><code>DynamicSprite.GetDrawingSurface</code></a> or <a href="Room.html#roomgetdrawingsurfaceforbackground"><code>Room.GetDrawingSurfaceForBackground</code></a>, and you can then use the following methods to draw onto the surface.</p>
<p><strong>IMPORTANT:</strong> You <strong>MUST</strong> call the <a href="DrawingSurface.html#drawingsurfacerelease"><code>Release</code></a> method when you have finished drawing onto the surface. This allows AGS to update its cached copies of the image and upload it to video memory if appropriate.</p>
<hr />
<section id="drawingsurfaceclear" class="level3">
<h3><a href="#drawingsurfaceclear"><code>DrawingSurface.Clear</code></a></h3>
<p><em>(Formerly known as <code>RawClearScreen</code>, which is now obsolete)</em></p>
<pre><code>DrawingSurface.Clear(optional int color)
</code></pre>
<p>Clears the surface to the specified COLOR (this is a number you can find in the Colors pane of the editor). The current contents of the surface will be lost.</p>
<p>If you do not supply the COLOR parameter, or use COLOR_TRANSPARENT, the surface will be cleared to be fully transparent.</p>
<p>Example:</p>
<pre><code>DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
surface.Clear(14);
surface.DrawingColor = 13;
surface.DrawCircle(160,100,50);
surface.Release();
</code></pre>
<p>clears the room background to be fully yellow, then draws a pink circle in the middle of it.</p>
<p><em>See also:</em> <a href="DrawingSurface.html#drawingsurfacedrawingcolor"><code>DrawingSurface.DrawingColor</code></a></p>
<hr />
</section>
<section id="drawingsurfacecreatecopy" class="level3">
<h3><a href="#drawingsurfacecreatecopy"><code>DrawingSurface.CreateCopy</code></a></h3>
<p><em>(Formerly known as <code>RawSaveScreen</code>, which is now obsolete)</em></p>
<pre><code>DrawingSurface* DrawingSurface.CreateCopy()
</code></pre>
<p>Makes a backup copy of the current surface, in order that it can be restored later. This could be useful to back up a background scene before writing over it, or to save a certain state of your drawing to restore later.</p>
<p>Unlike the obsolete RawSaveScreen command in previous versions of AGS, backup surfaces created with this command are not lost when the player changes room or restores a game. However, surfaces containing a copy of room backgrounds can be <strong>very large</strong>, using up a large amount of memory and can increase the save game sizes significantly. Therefore, it is <strong>strongly recommended</strong> that you Release any backup copy surfaces as soon as you are done with them.</p>
<p>Example:</p>
<pre><code>DrawingSurface *backup = surface.CreateCopy();
DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
surface.DrawTriangle(0,0,160,100,0,200);
surface.Release();
Wait(80);
surface = Room.GetDrawingSurfaceForBackground();
surface.DrawSurface(backup);
surface.Release();
backup.Release();
</code></pre>
<p>will save a copy of the room background, draw a triangle onto it, wait for a while and then restore the original background.</p>
<p><em>See also:</em> <a href="DrawingSurface.html#drawingsurfacedrawsurface"><code>DrawingSurface.DrawSurface</code></a></p>
<hr />
</section>
<section id="drawingsurfacedrawcircle" class="level3">
<h3><a href="#drawingsurfacedrawcircle"><code>DrawingSurface.DrawCircle</code></a></h3>
<p><em>(Formerly known as <code>RawDrawCircle</code>, which is now obsolete)</em></p>
<pre><code>DrawingSurface.DrawCircle(int x, int y, int radius)
</code></pre>
<p>Draws a filled circle of radius RADIUS with its center at (X,Y) in the current drawing color.</p>
<p>Example:</p>
<pre><code>DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
surface.DrawingColor = 14;
surface.DrawCircle(160,100,50);
surface.Release();
</code></pre>
<p>will draw a circle in the center of the screen, of 50 pixels radius.</p>
<p><em>See also:</em> <a href="DrawingSurface.html#drawingsurfacedrawline"><code>DrawingSurface.DrawLine</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawingcolor"><code>DrawingSurface.DrawingColor</code></a></p>
<hr />
</section>
<section id="drawingsurfacedrawimage" class="level3">
<h3><a href="#drawingsurfacedrawimage"><code>DrawingSurface.DrawImage</code></a></h3>
<p><em>(Formerly known as <code>RawDrawImage</code>, which is now obsolete)</em><br> <em>(Formerly known as <code>RawDrawImageResized</code>, which is now obsolete)</em><br> <em>(Formerly known as <code>RawDrawImageTransparent</code>, which is now obsolete)</em></p>
<pre><code>DrawingSurface.DrawImage(int x, int y, int slot, optional int transparency,
                         optional int width, optional int height,
                         optional int cut_x, optional  int cut_y, 
                         optional int cut_width, optional int cut_height)
</code></pre>
<p>Draws image SLOT from the sprite manager onto the surface at location (X,Y).</p>
<p>Optionally, you can also specify the transparency of the image. This is a number from 0-100; using a <em>transparency</em> of 50 will draw the image semi-transparent; using 0 means it will not be transparent.</p>
<p>You can also resize the image as you draw it. In order to do this, simply specify a <em>width</em> and <em>height</em> that you wish to resize the image to when it is drawn.</p>
<p>As of <strong>AGS 3.6.0</strong>, you can also cut the original image in a specific rectangle using it's x,y position and width and height.</p>
<p><strong>NOTE:</strong> This command only works if the image to be drawn is the same color depth as the surface that you are drawing onto.</p>
<p><strong>NOTE:</strong> Transparency does not work in 256-color games, or with 256-color sprites.</p>
<p><strong>NOTE:</strong> The X and Y co-ordinates given are ROOM co-ordinates, not SCREEN co-ordinates. This means that in a scrolling room you can draw outside the current visible area.</p>
<p>Example:</p>
<pre><code>DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
surface.DrawImage(100, 100, oDoor.Graphic, 40);
surface.Release();
</code></pre>
<p>will draw the <em>oDoor</em> object's graphic onto the room background at (100, 100), at <code>40%</code> transparency.</p>
<p><em>See also:</em> <a href="DrawingSurface.html#drawingsurfacedrawline"><code>DrawingSurface.DrawLine</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawstring"><code>DrawingSurface.DrawString</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawsurface"><code>DrawingSurface.DrawSurface</code></a>, <a href="Room.html#roomcolordepth"><code>Room.ColorDepth</code></a></p>
<hr />
</section>
<section id="drawingsurfacedrawline" class="level3">
<h3><a href="#drawingsurfacedrawline"><code>DrawingSurface.DrawLine</code></a></h3>
<p><em>(Formerly known as <code>RawDrawLine</code>, which is now obsolete)</em></p>
<pre><code>DrawingSurface.DrawLine(int from_x, int from_y, int to_x, int to_y,
                        optional int thickness)
</code></pre>
<p>Draws a line from (FROM_X, FROM_Y) to (TO_X, TO_Y) in the surface's current drawing color.</p>
<p>The <em>thickness</em> parameter allows you to specify how thick the line is, the default being 1 pixel.</p>
<p><strong>NOTE:</strong> The X and Y co-ordinates given are ROOM co-ordinates, not SCREEN co-ordinates. This means that in a scrolling room you can draw outside the current visible area.</p>
<p>Example:</p>
<pre><code>DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
surface.DrawingColor = 14;
surface.DrawLine(0, 0, 160, 100);
surface.Release();
</code></pre>
<p>will draw a line from the left top of the screen (0,0) to the middle of the screen (160,100);</p>
<p><em>See also:</em> <a href="DrawingSurface.html#drawingsurfacedrawcircle"><code>DrawingSurface.DrawCircle</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawrectangle"><code>DrawingSurface.DrawRectangle</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawtriangle"><code>DrawingSurface.DrawTriangle</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawingcolor"><code>DrawingSurface.DrawingColor</code></a></p>
<hr />
</section>
<section id="drawingsurfacedrawmessagewrapped" class="level3">
<h3><a href="#drawingsurfacedrawmessagewrapped"><code>DrawingSurface.DrawMessageWrapped</code></a></h3>
<p><em>(Formerly known as <code>RawPrintMessageWrapped</code>, which is now obsolete)</em></p>
<pre><code>DrawingSurface.DrawMessageWrapped(int x, int y, int width,
                                  FontType font, int message_number)
</code></pre>
<p>Draws the room message MESSAGE_NUMBER onto the surface at (x,y), using the specified FONT.</p>
<p>WIDTH is the width of the virtual textbox enclosing the text, and is the point that the text will wrap at. This command is designed for writing a long message to the screen with it wrapping normally like a standard label would do.</p>
<p>The text will be printed using the current drawing color.</p>
<p>Example:</p>
<pre><code>DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
surface.DrawingColor = 14;
surface.DrawMessageWrapped(80, 40, 160, Game.NormalFont, 10);
surface.Release();
</code></pre>
<p>will display message 10 in the center of the screen, starting from Y = 40.</p>
<p><em>See also:</em> <a href="DrawingSurface.html#drawingsurfacedrawstring"><code>DrawingSurface.DrawString</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawingcolor"><code>DrawingSurface.DrawingColor</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawstringwrapped"><code>DrawingSurface.DrawStringWrapped</code></a></p>
<hr />
</section>
<section id="drawingsurfacedrawpixel" class="level3">
<h3><a href="#drawingsurfacedrawpixel"><code>DrawingSurface.DrawPixel</code></a></h3>
<pre><code>DrawingSurface.DrawPixel(int x, int y)
</code></pre>
<p>Draws a single pixel onto the surface at (X,Y) in the current color. The pixel thickness respects the <a href="DrawingSurface.html#drawingsurfaceusehighrescoordinates"><code>UseHighResCoordinates</code></a> property.</p>
<p><strong>NOTE:</strong> This command is not fast enough to use repeatedly to build up an image. Only use it for single pixel adjustments.</p>
<p>Example:</p>
<pre><code>DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
surface.DrawingColor = 14;
surface.DrawPixel(50, 50);
surface.Release();
</code></pre>
<p>draws a yellow pixel in the top left of the room background</p>
<p><em>See also:</em> <a href="DrawingSurface.html#drawingsurfacedrawingcolor"><code>DrawingSurface.DrawingColor</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawline"><code>DrawingSurface.DrawLine</code></a>, <a href="DrawingSurface.html#drawingsurfacegetpixel"><code>DrawingSurface.GetPixel</code></a>, <a href="DrawingSurface.html#drawingsurfaceusehighrescoordinates"><code>DrawingSurface.UseHighResCoordinates</code></a></p>
<hr />
</section>
<section id="drawingsurfacedrawrectangle" class="level3">
<h3><a href="#drawingsurfacedrawrectangle"><code>DrawingSurface.DrawRectangle</code></a></h3>
<p><em>(Formerly known as <code>RawDrawRectangle</code>, which is now obsolete)</em></p>
<pre><code>DrawingSurface.DrawRectangle(int x1, int y1, int x2, int y2)
</code></pre>
<p>Draws a filled rectangle in the current color with its top-left corner at (x1,y1) and its bottom right corner at (x2, y2)</p>
<p><strong>NOTE:</strong> The X and Y co-ordinates given are ROOM co-ordinates, not SCREEN co-ordinates. This means that in a scrolling room you can draw outside the current visible area.</p>
<p>Example:</p>
<pre><code>DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
surface.DrawingColor = 14;
surface.DrawRectangle(0, 0, 160, 100);
surface.Release();
</code></pre>
<p>will draw a rectangle over the top left hand quarter of the screen.</p>
<p><em>See also:</em> <a href="DrawingSurface.html#drawingsurfacedrawimage"><code>DrawingSurface.DrawImage</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawline"><code>DrawingSurface.DrawLine</code></a></p>
<hr />
</section>
<section id="drawingsurfacedrawstring" class="level3">
<h3><a href="#drawingsurfacedrawstring"><code>DrawingSurface.DrawString</code></a></h3>
<p><em>(Formerly known as <code>RawPrint</code>, which is now obsolete)</em></p>
<pre><code>DrawingSurface.DrawString(int x, int y, FontType font, string text, ...)
</code></pre>
<p>Draws the <em>text</em> onto the surface at (x, y), using the supplied font number. The text will be drawn in the current drawing color.</p>
<p>You can insert the value of variables into the message. For more information, see the <a href="StringFormats.html">string formatting</a> section.</p>
<p>Example:</p>
<pre><code>DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
surface.DrawingColor = 14;
surface.DrawString(0, 100, Game.NormalFont, &quot;Text written into the background!&quot;);
surface.Release();
</code></pre>
<p>will write some text onto the middle-left of the room background</p>
<p><em>See also:</em> <a href="Globalfunctions_General.html#gettextwidth"><code>GetTextWidth</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawstringwrapped"><code>DrawingSurface.DrawStringWrapped</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawingcolor"><code>DrawingSurface.DrawingColor</code></a></p>
<hr />
</section>
<section id="drawingsurfacedrawstringwrapped" class="level3">
<h3><a href="#drawingsurfacedrawstringwrapped"><code>DrawingSurface.DrawStringWrapped</code></a></h3>
<pre><code>DrawingSurface.DrawStringWrapped(int x, int y, int width,
                                 FontType font, Alignment,
                                 const string text)
</code></pre>
<p>Draws the <em>text</em> onto the surface at (x,y), using the specified FONT.</p>
<p><em>width</em> is the width of the virtual textbox enclosing the text, and is the point that the text will wrap at. You can use the <em>alignment</em> parameter to determine how the text is horizontally aligned.</p>
<p>The text will be printed using the current drawing color.</p>
<p>Example:</p>
<pre><code>DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
surface.DrawingColor = 14;
surface.DrawStringWrapped(80, 40, 160, Game.NormalFont, eAlignCentre, &quot;Hello, my name is Bob.&quot;);
surface.Release();
</code></pre>
<p>will display the text in the center of the screen, starting from Y = 40.</p>
<p><em>Compatibility:</em> Supported by <strong>AGS 3.0.1</strong> and later versions.</p>
<p><em>See also:</em> <a href="DrawingSurface.html#drawingsurfacedrawstring"><code>DrawingSurface.DrawString</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawingcolor"><code>DrawingSurface.DrawingColor</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawmessagewrapped"><code>DrawingSurface.DrawMessageWrapped</code></a></p>
<hr />
</section>
<section id="drawingsurfacedrawsurface" class="level3">
<h3><a href="#drawingsurfacedrawsurface"><code>DrawingSurface.DrawSurface</code></a></h3>
<p><em>(Formerly known as <code>RawDrawFrameTransparent</code>, which is now obsolete)</em><br> <em>(Formerly known as <code>RawRestoreScreen</code>, which is now obsolete)</em></p>
<pre><code>DrawingSurface.DrawSurface(DrawingSurface* source, optional int transparency,
                          optional int x, optional int y, 
                          optional int width, optional int height,
                          optional int cut_x, optional  int cut_y, 
                          optional int cut_width, optional int cut_height)
</code></pre>
<p>Draws the specified surface on top of this surface, optionally using <em>transparency</em> percent transparency. As of <strong>AGS 3.6.0</strong>, it also supports additional parameters to draw a piece of the surface onto a specific area in the destination surface.</p>
<p>This allows you to perform day-to-night fading and other special effects.</p>
<p><strong>NOTE:</strong> You cannot use the <em>transparency</em> parameter with 256-color surfaces.</p>
<p><strong>NOTE:</strong> This command can be a bit on the slow side, so don't call it from repeatedly_execute.</p>
<p><strong>TIP:</strong> If you want to gradually fade in a second background, create a copy of the original surface and then restore it after each iteration, otherwise the backgrounds will converge too quickly.</p>
<p>Example:</p>
<pre><code>DrawingSurface *mainBackground = Room.GetDrawingSurfaceForBackground(0);
DrawingSurface *nightBackground = Room.GetDrawingSurfaceForBackground(1);
mainBackground.DrawSurface(nightBackground, 50);
mainBackground.Release();
nightBackground.Release();
</code></pre>
<p>this will draw background frame 1 onto frame 0 at 50<code>%</code> opacity.</p>
<p><em>See also:</em> <a href="DrawingSurface.html#drawingsurfacedrawimage"><code>DrawingSurface.DrawImage</code></a>, <a href="Globalfunctions_General.html#setambienttint"><code>SetAmbientTint</code></a></p>
<hr />
</section>
<section id="drawingsurfacedrawtriangle" class="level3">
<h3><a href="#drawingsurfacedrawtriangle"><code>DrawingSurface.DrawTriangle</code></a></h3>
<p><em>(Formerly known as <code>RawDrawTriangle</code>, which is now obsolete)</em></p>
<pre><code>DrawingSurface.DrawTriangle(int x1, int y1, int x2, int y2, int x3, int y3)
</code></pre>
<p>Draws a filled triangle in the current color with corners at the points (x1,y1), (x2,y2) and (x3,y3).</p>
<p>Well, don't look at me, you might find it useful for something :-)</p>
<p>Example:</p>
<pre><code>DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
surface.DrawingColor = 14;
surface.DrawTriangle(0,0,160,100,0,200);
surface.Release();
</code></pre>
<p>will draw a triangle with corners at the points (0,0),(160,100),(0,200).</p>
<p><em>See also:</em> <a href="DrawingSurface.html#drawingsurfacedrawimage"><code>DrawingSurface.DrawImage</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawline"><code>DrawingSurface.DrawLine</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawrectangle"><code>DrawingSurface.DrawRectangle</code></a></p>
<hr />
</section>
<section id="drawingsurfacerelease" class="level3">
<h3><a href="#drawingsurfacerelease"><code>DrawingSurface.Release</code></a></h3>
<pre><code>DrawingSurface.Release()
</code></pre>
<p>Tells AGS that you have finished drawing onto this surface, and that AGS can now upload the changed image into video memory.</p>
<p>After calling this method, you can no longer use the DrawingSurface instance. To do any further drawing, you need to get the surface again.</p>
<p>Example:</p>
<pre><code>DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
surface.DrawingColor = 14;
surface.DrawLine(0, 0, 50, 50);
surface.Release();
</code></pre>
<p>draws a yellow diagonal line across the top-left of the current room background, then releases the image.</p>
<p><em>See also:</em> <a href="DynamicSprite.html#dynamicspritegetdrawingsurface"><code>DynamicSprite.GetDrawingSurface</code></a>, <a href="Room.html#roomgetdrawingsurfaceforbackground"><code>Room.GetDrawingSurfaceForBackground</code></a></p>
<hr />
</section>
<section id="drawingsurfacedrawingcolor" class="level3">
<h3><a href="#drawingsurfacedrawingcolor"><code>DrawingSurface.DrawingColor</code></a></h3>
<p><em>(Formerly known as <code>RawSetColor</code>, which is now obsolete)</em></p>
<pre><code>int DrawingSurface.DrawingColor
</code></pre>
<p>Gets/sets the current drawing color on this surface. Set this before using commands like <a href="DrawingSurface.html#drawingsurfacedrawline"><code>DrawLine</code></a>, which use this color for their drawing.</p>
<p>You can set this either to an AGS Color Number (as you'd get from the Colors pane in the editor) or to the special constant COLOR_TRANSPARENT, which allows you to draw transparent areas onto the surface.</p>
<p>Example:</p>
<pre><code>DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
surface.DrawingColor = 14;
surface.DrawLine(0, 0, 160, 100);
surface.DrawingColor = Game.GetColorFromRGB(255, 255, 255);
surface.DrawLine(0, 199, 160, 100);
surface.Release();
</code></pre>
<p>will draw a yellow line from the left top of the screen (0,0) to the middle of the screen (160,100), and a white line from the bottom left to the middle.</p>
<p><em>See also:</em> <a href="DrawingSurface.html#drawingsurfacedrawcircle"><code>DrawingSurface.DrawCircle</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawline"><code>DrawingSurface.DrawLine</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawrectangle"><code>DrawingSurface.DrawRectangle</code></a>, <a href="Game.html#gamegetcolorfromrgb"><code>Game.GetColorFromRGB</code></a></p>
<hr />
</section>
<section id="drawingsurfacegetpixel" class="level3">
<h3><a href="#drawingsurfacegetpixel"><code>DrawingSurface.GetPixel</code></a></h3>
<pre><code>int DrawingSurface.GetPixel(int x, int y)
</code></pre>
<p>Returns the AGS Color Number of the pixel at (X,Y) on the surface.</p>
<p><strong>NOTE:</strong> In high-color games, the first 32 color numbers have a special meaning due to an AGS feature which maintains compatibility with 8-bit games. Therefore, if you draw onto the surface using a blue color number 0-31 you will get a different number when you GetPixel -- and in fact the color drawn may not be what you expect. To get around this, add 1 Red or Green component to adjust the color number out of this range.</p>
<p><strong>NOTE:</strong> This command is relatively slow. Don't use it to try and process an entire image.</p>
<p>Example:</p>
<pre><code>DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
Display(&quot;The color of the middle pixel is %d.&quot;, surface.GetPixel(160, 100));
surface.Release();
</code></pre>
<p>displays the pixel color of the center pixel on the screen.</p>
<p><em>Compatibility:</em> Supported by <strong>AGS 3.0.1</strong> and later versions.</p>
<p><em>See also:</em> <a href="DrawingSurface.html#drawingsurfacedrawingcolor"><code>DrawingSurface.DrawingColor</code></a>, <a href="DrawingSurface.html#drawingsurfacedrawpixel"><code>DrawingSurface.DrawPixel</code></a>, <a href="DrawingSurface.html#drawingsurfaceusehighrescoordinates"><code>DrawingSurface.UseHighResCoordinates</code></a></p>
<hr />
</section>
<section id="drawingsurfaceheight" class="level3">
<h3><a href="#drawingsurfaceheight"><code>DrawingSurface.Height</code></a></h3>
<pre><code>readonly int DrawingSurface.Height
</code></pre>
<p>Gets the height of the surface.</p>
<p>Example:</p>
<pre><code>DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
Display(&quot;The background is %d x %d!&quot;, surface.Width, surface.Height);
surface.Release();
</code></pre>
<p>displays the size of the surface to the player</p>
<p><em>See also:</em> <a href="DrawingSurface.html#drawingsurfaceusehighrescoordinates"><code>DrawingSurface.UseHighResCoordinates</code></a>, <a href="DrawingSurface.html#drawingsurfacewidth"><code>DrawingSurface.Width</code></a></p>
<hr />
</section>
<section id="drawingsurfaceusehighrescoordinates" class="level3">
<h3><a href="#drawingsurfaceusehighrescoordinates"><code>DrawingSurface.UseHighResCoordinates</code></a></h3>
<p><strong>This property is obsolete since AGS 3.5.0 and not recommended for use at all.</strong></p>
<pre><code>bool DrawingSurface.UseHighResCoordinates
</code></pre>
<p>Gets/sets whether you want to use high-resolution co-ordinates with this surface.</p>
<p>By default, this property will be set such that drawing surface co-ordinates use the same co-ordinate system as the rest of the game, as per the "Use low-res co-ordinates in script" game setting. However, if your game is 640x400 or higher you can customize whether this drawing surface uses native co-ordinates or the low-res 320x200 co-ordinates by changing this property.</p>
<p>Setting this property affects <strong>ALL</strong> other commands performed on this drawing surface, including the <a href="DrawingSurface.html#drawingsurfacewidth"><code>Width</code></a> and <a href="DrawingSurface.html#drawingsurfaceheight"><code>Height</code></a> properties.</p>
<p><strong>IMPORTANT:</strong> This property is a remnant of the old and since deprecated feature in AGS which allowed to treat all coordinates in high-resolution games as if they were for low-resolution. For example: have 640x400 game but use 320x200 measurements in script, which would make each drawing operation to be performed x2 thicker on screen.<br> Since AGS 3.5.0 this property is ignored unless you have backwards-compatible "Allow relative asset resolutions" option enabled in General Settings.</p>
<hr />
</section>
<section id="drawingsurfacewidth" class="level3">
<h3><a href="#drawingsurfacewidth"><code>DrawingSurface.Width</code></a></h3>
<pre><code>readonly int DrawingSurface.Width
</code></pre>
<p>Gets the width of the surface.</p>
<p>Example:</p>
<pre><code>DrawingSurface *surface = Room.GetDrawingSurfaceForBackground();
Display(&quot;The background is %d x %d!&quot;, surface.Width, surface.Height);
surface.Release();
</code></pre>
<p>displays the size of the surface to the player</p>
<p><em>See also:</em> <a href="DrawingSurface.html#drawingsurfaceheight"><code>DrawingSurface.Height</code></a>, <a href="DrawingSurface.html#drawingsurfaceusehighrescoordinates"><code>DrawingSurface.UseHighResCoordinates</code></a></p>
</section>
</section>
  </main>


  <footer>
    <p>
      <a href="jslicensing.html" data-jslicense="1">Third-party JavaScript licensing</a><br>
      Build: 71e20d0fd8b896a257417446b505194dec21601f
    </p>
  </footer>

  <script src="js/search.js"></script>
  </div>
</body>
</html>
